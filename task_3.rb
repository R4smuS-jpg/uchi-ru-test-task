el1 = true and false # => el1 == true
el2 = true && false # => el2 == false

p el1
p el2

# && - логический оператор. Его задача вернуть true или false.
# Его приоритет выполнения выше, чем у оператора присваивания,
# следовательно, el2 = 1 и 0, что по законам булевой математики равняется 0, т.е. false

# and - оператор, так скажем, контроля работы программы.
# Но в данном случае он ведёт себя как логический оператор с иным приоритетом выполнения.
# Его приоритет ниже чем, у оператора присваивания, так что
# он выполняется после того, как el1 присвоилось значения true.
# (el1 = true) and false <- типа такого
# так что к el1 последующий false не имеет никакого отношения.
